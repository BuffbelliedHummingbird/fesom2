! PDAF_V2.0

! $Id: generate_covar.F90 1604 2016-05-30 06:42:16Z lnerger $

!Modified by QT       2017-12-12 ---- for AWI-CM 
!Modified by QT       2017-12-19
!Modified by Frauke B 2022-02-22 ---- for FESOM2.1

! !Program: generate_covar --- Compute covariance matrix from state trajectory
PROGRAM generate_covar

! !DESCRIPTION:
! This programm to computes a covariance matrix from a
! model trajectory of FESOM2.1. The matrix is decomposed in
! EOFs and stored in form of eigenvalues and eigenvectors.
!
! The matrix is generated by a singular value decomposition
! of the perturbation matrix of a long state trajectory
! about its long time mean.
!
! 1) the state vector is structured (...)^T; fields defined in "fproperties" and "idx"
! 2) u and v structure is according to u and v being interpolated from elements onto nodes
! 3) output frequency is every day;
! 4) only one output file, including the running mean, singular values and singular vectors
!
! !NOTES:
! Type "ulimit -s unlimited" before executing in case of segmentation
! fault error on Ollie.

! Three arrays (svdU, states, run_meanstate) each need:
! dimstate = 30192204; maxtimes = 73; REAL = 4 bytes
! allocate approx. 8800 MB

! !USES:
  IMPLICIT NONE

  INCLUDE 'netcdf.inc'


! Local variables
  
  CHARACTER(len=250) :: inpath, outpath                 ! File paths
  CHARACTER(len=250) :: outfile                         ! File names   -- output
  CHARACTER(len=250) :: ncfile_out                      ! File name including path
  CHARACTER(len=250) :: attstr                          ! Attribute string for NC (NetCDF) output
  
  INTEGER :: i, j, k, s, iter, maxtimes, rank, b, bf    ! Counters
  INTEGER :: ncid_out                                   ! NC file IDs
  INTEGER :: id_dim, id_time, id_state                  ! NC dimension and variable IDs
  INTEGER :: id_sigma, id_svec                          ! NC dimension and variable IDs
  INTEGER :: dimid_rank, dimid_state, dimid_one, dimid_nfields ! NC dimension and variable IDs
  INTEGER :: dimid_nod2, dimid_nz, dimid_elem           ! NC dimension and variable IDs
  INTEGER :: dimid_2D, dimid_tracer3D, dimid_w          ! NC dimension and variable IDs
  INTEGER :: dimid_maxtimes                             ! NC dimension and variable IDs
  INTEGER :: nod2, nz, elem                             ! Number of 2d nodes, depth levels and 2d elements
  INTEGER :: steps, dim_state                           ! Dimensions
  INTEGER :: stat(200)                                  ! Status for NC operations
  INTEGER :: countv2(2), startv2(2)                     ! Vectors for NC operations (2D)
  INTEGER :: countv3(3), startv3(3)                     ! Vectors for NC operations (3D)
  INTEGER :: dimids(2)                                  ! Vector for NC operations 
  INTEGER :: nfields                                    ! Number of fields
  INTEGER :: id_field                                   ! Field
  INTEGER :: hwindow                                    ! Half time window
  INTEGER :: ostep                                      ! Time step                             
  INTEGER :: status                                     ! Status Flag for PDAF routine
  
  INTEGER, ALLOCATABLE :: dim_fields(:)                              ! Size of field
  REAL, ALLOCATABLE    :: stddev(:)                                  ! STDDEV of field
  INTEGER, ALLOCATABLE :: offsets(:)                                 ! Offset of fields
  INTEGER, ALLOCATABLE :: fields_on_nod(:)                           ! Fields that are on nodes
  INTEGER, ALLOCATABLE :: fields_on_elem(:)                          ! Fields that are on elemements
  
  REAL :: limit                                         ! Lower limit for singular values
  
  REAL, ALLOCATABLE :: times(:)                         ! Array of times from NC file
  REAL, ALLOCATABLE :: states(:, :)                     ! State trajectory
  REAL, ALLOCATABLE :: run_meanstate (:, :)             ! Running mean state
  REAL, ALLOCATABLE :: meanstate(:)                     ! Mean state of trajectory
  REAL,ALLOCATABLE,DIMENSION(:) :: svals                ! field of singular values
  REAL,ALLOCATABLE,DIMENSION(:,:) :: svdU               ! left singular vectors

  ! Controls for PDAF_eofcovar
  INTEGER :: remove_mean  ! (1) Let PDAF_eofcovar compute and subtract the mean state;
                          ! (0) mean already removed from trajectory
  INTEGER :: do_mv        ! (1) to perform multivariate normalization; (0) no normalization
  
  ! Variables for interpolation of u and v
  REAL, ALLOCATABLE ::    u_orig(:), v_orig(:)        ! Velocities before interpolation
  INTEGER ::              l, n, el, c                 ! Counters
  INTEGER, ALLOCATABLE :: nod_in_elem2D_num(:), &     ! Number of elements sharing a vertex
                          nod_in_elem2D(:,:), &       ! Elements sharing vertex
                          nlevels(:), &               ! Number of depth levels at elements considering topography
                          nlevels_nod2D(:)            ! Number of depth levels at nodes considering topography
  INTEGER(kind=8), ALLOCATABLE :: elem_area(:)        ! Area of elements (rounded to square meters)
  INTEGER ::              nod_in_elem2D_max           ! Maximum number of elements sharing a vertex
  REAL ::                 tvol, &                     ! Area sum of elements sharing a vertex
                          tx, ty                      ! To sum up velocities weighted by area

  CHARACTER(len=120) ::   file_nod_in_elem, &         ! File names
                          file_elem_area, &
                          file_nlevels, &
                          file_nlevels_nod2D
  INTEGER ::              fID_nod_in_elem, &          ! File IDs
                          fID_elem_area, &
                          fID_nlevels, &
                          fID_nlevels_nod2D
                          
                          
integer :: fmin, fmax
  
  TYPE field_ids
     INTEGER :: ssh
     INTEGER :: u
     INTEGER :: v
     INTEGER :: temp
     INTEGER :: salt
     INTEGER :: DIC
     INTEGER :: Alk
     INTEGER :: DIN
     INTEGER :: O2
END TYPE field_ids
  
  TYPE(field_ids) :: idx                  ! Type variable holding field IDs in state vector
                          
  type state_field
   integer :: ndims = 0                   ! Number of field dimensions (1 or 2)
   character(len= 10) :: variable = ''    ! Name of field
   character(len=250) :: filename = ''    ! File name input incl. path
   integer :: ncid = 0                    ! ID nc-file input
   integer :: fid = 0                     ! Field ID (in/output file)
   integer :: mid = 0                     ! Mean field ID (output file)
   integer :: sid = 0                     ! Singular vector ID
   logical :: dfield = .false.            ! Diagnostic fields derived from model fields
                                          ! (e.g. total chlorophyll,
                                          ! derived from DiaChl + PhyChl)
  end type state_field

  type(state_field), allocatable :: fproperties(:) ! Type variable holding the
                                                   ! definitions of model fields
                                                 

! ************************************************
! *** Configuration                            ***
! ************************************************

  ! Number of fields in state vector
  nfields = 9

  ! Maximum number of time slices to consider
  maxtimes = 72

  ! Set do_mv=1 to activate normalization; 0 to run without normalization
  do_mv = 0  

  ! Path to and name of file holding model trajectory
  inpath = '/albedo/work/projects/p_recompdaf/frbunsen/modelruns/fesom2/yr2016_NoAlkRestoring/'

  ! Path to and name of output file holding covariance matrix
  outpath = '/albedo/work/projects/p_recompdaf/frbunsen/modelruns/BGC9_covar/'
  outfile = 'cov.nc'

  ! Lower limit for eigenvalue
  limit = 1.0e-12

  ! Half time window for running mean (2*irange+1)
  hwindow = 3 ! 6 days
  
  ! Time step (only consider every x-th value of model output)
  ostep = 5  ! every 5th day in daily output

  ! Note: multivariate normalization can be useful if there are several fields
  !       with difference variances. Here, we have 7 fields.
  
  ! Maximum number of elements sharing a vertex in CORE2 mesh
  nod_in_elem2D_max = 9
  
  ! ************************************************
  ! *** Configuration biogeochemistry            ***
  ! ************************************************
  
  ! Number of fields and their indeces in state vector
  fmin = 1
  fmax = nfields
  allocate(fproperties(nfields))
  
  idx% ssh  = 1
  idx% u    = 2
  idx% v    = 3
  idx% temp = 4
  idx% salt = 5
  idx% DIC  = 6
  idx% Alk  = 7
  idx% DIN  = 8
  idx% O2   = 9

  fproperties(idx% ssh) % ndims = 1
  fproperties(idx% ssh) % variable = 'ssh'
  
  fproperties(idx% u) % ndims = 2
  fproperties(idx% u) % variable = 'u'

  fproperties(idx% v) % ndims = 2
  fproperties(idx% v) % variable = 'v'

  fproperties(idx% temp) % ndims = 2
  fproperties(idx% temp) % variable = 'temp'

  fproperties(idx% salt) % ndims = 2
  fproperties(idx% salt) % variable = 'salt'

  fproperties(idx% DIC) % ndims = 2
  fproperties(idx% DIC) % variable = 'DIC' 

  fproperties(idx% Alk) % ndims = 2
  fproperties(idx% Alk) % variable = 'Alk'

  fproperties(idx% DIN) % ndims = 2
  fproperties(idx% DIN) % variable = 'DIN'

  fproperties(idx% O2) % ndims = 2
  fproperties(idx% O2) % variable = 'O2'
  
  do b=fmin, fmax
    if (fproperties(b) % dfield) CYCLE
    fproperties(b) % filename = trim(inpath)//trim(fproperties(b) % variable)//'.fesom.2016.nc'
  enddo
  
  allocate(fields_on_nod(7))
  fields_on_nod  = (/ idx% ssh, idx% temp, idx% salt, idx% DIC, idx% Alk, idx% DIN, idx% O2 /)
  allocate(fields_on_elem(2))
  fields_on_elem = (/ idx% u, idx% v /)

! ************************************************
! *** Init                                     ***
! ************************************************

  allocate(dim_fields(nfields))
  allocate(stddev(nfields)) 
  allocate(offsets(nfields))


  WRITE (*,'(10x,a)')  '*******************************************'
  WRITE (*,'(10x,a)')  '*             GENERATE_COVAR              *'
  WRITE (*,'(10x,a)')  '*                                         *'
  WRITE (*,'(10x,a)')  '*    Compute covariance matrix and mean   *'
  WRITE (*,'(10x,a)')  '*     state from a sequence of states.    *'
  WRITE (*,'(10x,a)')  '*                                         *'
  WRITE (*,'(10x,a)')  '*   Write covar matrix as scaled eigen-   *'
  WRITE (*,'(10x,a)')  '*    vectors and singular values into     *'
  WRITE (*,'(10x,a)')  '*              NetCDF file                *'
  WRITE (*,'(10x,a/)') '*******************************************'
  
  do b=fmin, fmax
    if (fproperties(b) % dfield) CYCLE
    write(*,*) 'Read ',trim(fproperties(b) % variable),' trajectory from file: ',trim(fproperties(b) % filename)
  enddo

  ncfile_out = TRIM(outpath)//TRIM(outfile)
  WRITE (*,*) 'Write output to file: ',TRIM(ncfile_out)
  
! ***********************************************************
! *** Read mesh info to interpolate velocities            ***
! ***********************************************************
  WRITE (*,*) 'Reading mesh info to interpolate velocities:'
  
  nod2              = 126858
  elem              = 244659
  
  ALLOCATE(nod_in_elem2D(nod_in_elem2D_max,nod2))
  ALLOCATE(nod_in_elem2D_num(nod2))
  ALLOCATE(nlevels(elem))
  ALLOCATE(nlevels_nod2D(nod2))
  ALLOCATE(elem_area(elem))

  file_nod_in_elem   = 'elems_at_node.txt'
  file_nlevels       = 'nlevels.txt'
  file_nlevels_nod2D = 'nlevels_nod2D.txt'
  file_elem_area     = 'elem_area.txt'

  WRITE (*,*) ' - Reading file_nod_in_elem'
  open(fID_nod_in_elem, file=trim(file_nod_in_elem))
  DO l = 1,nod2
     read(fID_nod_in_elem,*)  nod_in_elem2D_num(l)
     read(fID_nod_in_elem,*)  nod_in_elem2D(:nod_in_elem2D_num(l),l)
     
     nod_in_elem2D(:nod_in_elem2D_num(l),l) = nod_in_elem2D(:nod_in_elem2D_num(l),l) + 1
  END DO
  close(fID_nod_in_elem)

  WRITE (*,*) ' - Reading in file_elem_area'
  open(fID_elem_area, file=trim(file_elem_area))
  read(fID_elem_area,*) elem_area
  close(fID_elem_area)

  WRITE (*,*) ' - Reading in file_nlevels'
  open(fID_nlevels, file=trim(file_nlevels))
  read(fID_nlevels,*) nlevels
  close(fID_nlevels)
  
  WRITE (*,*) ' - Reading in file_nlevels_nod2D'
  open(fID_nlevels_nod2D, file=trim(file_nlevels_nod2D))
  read(fID_nlevels_nod2D,*) nlevels_nod2D
  close(fID_nlevels)
  
! ******************************************************************
! ***  Open trajectory files and read dimensions                 ***
! ******************************************************************

  s = 1
  do b=fmin, fmax
    
    ! get file ID
    stat(s) = NF_OPEN(fproperties(b)% filename, NF_NOWRITE, fproperties(b)% ncid)
    IF (stat(s) /= NF_NOERR) WRITE(*, *) 'NetCDF error in reading file, no.', s, ' (', fproperties(b)% variable, ')'
    s = s+1
    
    ! get field ID for trajectory data
    stat(s) = NF_INQ_VARID(fproperties(b)% ncid, fproperties(b)% variable, fproperties(b)% fid)
    IF (stat(s) /= NF_NOERR) WRITE(*, *) 'NetCDF error in reading field ID, no.', s, ' (', fproperties(b)% variable, ')'
    s = s+1
          
  enddo
  
  ! Read time and depth from one file (e.g. temperature)
  b = idx% temp
  
  s = 1
  stat(s) = NF_INQ_DIMID(fproperties(b)% ncid, 'time', id_dim)
  IF (stat(s) /= NF_NOERR) WRITE(*, *) 'NetCDF error in reading time ID'
  s = s + 1
  stat(s) = NF_INQ_DIMLEN(fproperties(b)% ncid, id_dim, steps)
  IF (stat(s) /= NF_NOERR) WRITE(*, *) 'NetCDF error in getting time steps'
  s = s + 1

  stat(s) = NF_INQ_DIMID(fproperties(b)% ncid, 'nz1', id_dim)
  IF (stat(s) /= NF_NOERR) WRITE(*, *) 'NetCDF error in reading layers ID'
  s = s + 1
  stat(s) = NF_INQ_DIMLEN(fproperties(b)% ncid, id_dim, nz)
  IF (stat(s) /= NF_NOERR) WRITE(*, *) 'NetCDF error in getting layers'
  s = s + 1

  ! Write dimensions
  WRITE (*,'(/1x,a)') 'Dimensions of model output:'
  WRITE (*,'(10x,1x,a25,i12)') 'nod2       ', nod2
  WRITE (*,'(10x,1x,a25,i12)') 'elem       ', elem
  WRITE (*,'(10x,1x,a25,i12)') 'nz         ', nz
  WRITE (*,'(10x,1x,a25,i12)') 'nfields    ', nfields
  WRITE (*,'(10x,1x,a25,i10)') 'time steps ', steps

  IF (steps < ((maxtimes-1)*ostep+1)) THEN
     WRITE (*,'(1x,a)') '!! Number of available time slices is smaller than maxtimes - resetting !!'
     maxtimes = steps/ostep
  END IF
  WRITE (*,'(13x,a8,i10)') 'maxtimes', maxtimes
  
! ******************************************************************
! *** Define state vector                                        ***
! ******************************************************************
  
  ! Define field dimensions
  do b=fmin, fmax
     if (fproperties(b) % ndims == 2) dim_fields(b) = nod2*nz
     if (fproperties(b) % ndims == 1) dim_fields(b) = nod2
  enddo

 ! Define state dimension
  dim_state = sum(dim_fields)

  WRITE (*,'(5x,a,i12)') 'dim_state', dim_state

  ! Define offsets
  offsets(1)=0
  do b=2, fmax
     offsets(b) = offsets(b-1) + dim_fields(b-1)
  enddo

! ****************************
! *** Read trajectory data ***
! ****************************

  WRITE (*,'(/1x,a)') '------- Read trajectory -------------'
  ALLOCATE(states(dim_state, maxtimes))
  ALLOCATE(u_orig(nz*elem))
  ALLOCATE(v_orig(nz*elem))
  
  read_in: DO iter = 1, maxtimes*ostep, ostep
 
  ! ****************************
  ! *** Fields on elements   ***
  ! ****************************
  startv3(1) = 1
  countv3(1) = nz    ! get nz (i.e. all) elements starting from 1
  startv3(2) = 1     
  countv3(2) = elem  ! get elem (i.e. all) elements starting from 1
  startv3(3) = iter
  countv3(3) = 1     ! get one element at time step "iter"

  ! read from netCDF
  ! u
  b = idx% u
  IF (iter==1) WRITE(*,*) '- Read variable ', fproperties(b)% variable,' at step 1'
  
  stat(1) = NF_GET_VARA_DOUBLE(fproperties(b)% ncid, fproperties(b)% fid, &
                               startv3, countv3, &
                               u_orig)
  IF (stat(1) /= NF_NOERR) WRITE(*, *) 'NetCDF error in reading variable no. ', s, ' (', fproperties(b)% variable, ')'
     
  ! v
  b = idx% v
  IF (iter==1) WRITE(*,*) '- Read variable ', fproperties(b)% variable,' at step 1'
  
  stat(1) = NF_GET_VARA_DOUBLE(fproperties(b)% ncid, fproperties(b)% fid, &
                               startv3, countv3, &
                               v_orig)
  IF (stat(1) /= NF_NOERR) WRITE(*, *) 'NetCDF error in reading variable no. ', s, ' (', fproperties(b)% variable, ')'
      
  ! ******************************************************************
  ! *** Interpolation of u and v from elements onto nodes          ***
  ! ******************************************************************
  IF (iter==1) THEN
  WRITE (*,*) '- Interpolation of u and v at step 1'
  END IF
  
  DO n = 1,nod2
     DO l = 1, nlevels_nod2D(n)
        tvol=0.0
        tx  =0.0
        ty  =0.0
           DO c = 1, nod_in_elem2D_num(n)
               el = nod_in_elem2D(c,n)
               if (nlevels(el)<l) cycle
               tvol = tvol + elem_area(el)
               tx = tx + u_orig((el-1)*nz+l) *elem_area(el)
               ty = ty + v_orig((el-1)*nz+l) *elem_area(el)
           END DO
        states(offsets(idx% u)+(n-1)*nz+l,iter/ostep+1) = tx/tvol ! u
        states(offsets(idx% v)+(n-1)*nz+l,iter/ostep+1) = ty/tvol ! v
     END DO
  END DO
      
! ****************************
! *** Read fields on nodes ***
! ****************************
  ! surface fields
  startv2(1) = 1     
  countv2(1) = nod2  ! get nod2 (i.e. all) value starting from 1
  startv2(2) = iter
  countv2(2) = 1     ! get one value at time step "iter"
  
  ! 3D-fields
  startv3(1) = 1     
  countv3(1) = nz    ! get nz (i.e. all) values starting from 1
  startv3(2) = 1
  countv3(2) = nod2  ! get nod2 (i.e. all) values starting from 1
  startv3(3) = iter
  countv3(3) = 1     ! get one element at time step "iter"
  
  ! read from netCDF     
  s=1
  do bf=1, size(fields_on_nod)

     b=fields_on_nod(bf)
  
     IF (iter==1) WRITE(*,*) '- Read variable ',fproperties(b)% variable,' at step 1'
  
     if (fproperties(b)% ndims == 1) then
       ! surface fields
       stat(s) = NF_GET_VARA_DOUBLE(fproperties(b)% ncid, fproperties(b)% fid, startv2, countv2, &
       states(offsets(b)+1 : offsets(b)+dim_fields(b), iter/ostep+1))
     
     elseif (fproperties(b)% ndims == 2) then
       ! 3D-fields       
       stat(s) = NF_GET_VARA_DOUBLE(fproperties(b)% ncid, fproperties(b)% fid, startv3, countv3, &
       states(offsets(b)+1 : offsets(b)+dim_fields(b), iter/ostep+1))
       
     endif ! surface / 3D-fields
     
     IF (stat(s) /= NF_NOERR) WRITE(*, *) 'NetCDF error in reading variable no. ', s, ' (', fproperties(b)% variable, ')'
     s = s+1
     
  enddo ! bf=1, size(fields_on_nod)
      
  END DO read_in

  ! Close trajectory file

  s=1
  do b=fmin, fmax
    
    stat(s) = NF_CLOSE(fproperties(b)% ncid)
    
    IF (stat(s) /= NF_NOERR) WRITE(*, *) 'NetCDF error in closing input file, no. ', s, ' (', fproperties(b)% variable, ')'
    s = s+1
     
  enddo ! fmin, fmax

! **********************************
! *** Compute running mean state ***
! **********************************

  WRITE (*,*) 'Compute running mean over', maxtimes,' snapshots at every ', ostep, '-th model output step'
  ALLOCATE(meanstate(dim_state))
  ALLOCATE(run_meanstate(dim_state, maxtimes))
  
  DO i = 1, maxtimes
     meanstate = 0.0

     ! "middle/main" part of timeseries
     IF (i > hwindow .AND. i <= (maxtimes - hwindow)) THEN
        Do j = i - hwindow, i + hwindow
           meanstate = meanstate + states (:, j)
        END DO

     ! near start of timeseries
     ELSE IF (i <= hwindow) THEN
        DO j = 1, i + hwindow
           meanstate = meanstate + states (:, j)
        END DO
        DO j = maxtimes - hwindow +i, maxtimes
           meanstate = meanstate + states (:, j)
        END DO

     ! towards end of timeseries
     ELSE IF (i > maxtimes - hwindow) THEN
        DO j = i - hwindow, maxtimes
           meanstate = meanstate + states (:, j)
        END DO        
        DO j = 1, i + hwindow - maxtimes
            meanstate = meanstate + states (:, j)
         END DO
     END IF
     
     meanstate = meanstate / (2 * hwindow + 1)
     run_meanstate (:, i) = meanstate
 
  END DO
  
  ! get residual
  states = states - run_meanstate  



! *********************************************************
! *** Singular value decomposition of covariance matrix ***
! ***                                                   ***
! *** The covariance matrix is given by the state       ***
! *** sequences X of k states as                        ***
! ***          -1    _     _ T        T                 ***
! *** P = (k-1)   (X-X) (X-X)  = U L U  (EVP)           ***
! ***                                                   ***
! *** Thus we compute the singular value decomposition  ***
! ***     _        T            -1    2  T              ***
! ***   X-X = U S V ;  P = (k-1)   U S  U               ***
! ***                                                   ***
! ***                         -1/2                      ***
! *** and we store U and (k-1)     S in a NetCDF file.  ***
! *********************************************************

  WRITE (*,'(/1x,a)') '------- Compute covariance matrix decomposition -------------'

  ! PDAF_eofcovar should compute and subtract the mean state from Trajectory 
  ! before decomposition. Afterwards, it's added again.
  remove_mean = 0

  ! Allocate arrays for singular values and vectors
  WRITE(*, *) 'Allocate svals'
  ALLOCATE(svals(maxtimes))
  
  WRITE(*, *) 'Allocate svdU'
  ALLOCATE(svdU(dim_state, maxtimes))
  
  WRITE(*, *) 'Call routine generating matrix decomposition'
  ! Call routine generating matrix decomposition
  CALL PDAF_eofcovar(dim_state, maxtimes, nfields, dim_fields, offsets, &
       remove_mean, do_mv, states, stddev, svals, svdU, meanstate, 1, status)
 
! *********************************************************
! *** Write mean state and decomposed covariance matrix ***
! *********************************************************

  ! *** Determine rank to write ***

  getlimit: DO i = 1, maxtimes
     IF (svals(i) >= limit) THEN
        rank = i
     ELSE
        EXIT getlimit
     END IF
  END DO getlimit
  IF (rank < maxtimes) THEN
     WRITE (*,'(1x,a,i6,a,es10.2)') &
          'Use maximum of ', rank, ' eigenvectors due to eigenvalue-limit of ',limit
  END IF
  IF (rank == maxtimes) THEN
     rank = maxtimes - 1
     WRITE (*,'(5x,a,i4)') '++ reset rank to ',rank
  END IF

  WRITE (*,'(5x,a)') 'Singular values: '
  DO i = 1, rank
    WRITE (*, '(10x, i4, es12.3)') i, svals(i)
  END DO
  
  WRITE (*,'(5x,a)') 'svdU: '
  DO b = 1,fmax
    DO i = 1, rank
      WRITE (*, '(10x, i4, 2x, a, es12.3)') i, fproperties(b) % variable, svdU(1+offsets(b),i)
    END DO
  END DO

  WRITE (*,'(/1x,a)') '------- Write decomposed covariance matrix -------------'

  ! *** Initialize file
  s = 1
  stat(s) = NF_CREATE(ncfile_out, NF_64BIT_OFFSET, ncid_out)

  IF (do_mv == 1) THEN
     attstr = 'Running mean state, scaled singular vectors and values of multivariate decomposed covariance matrix for FESOM2.1'
  ELSE
     attstr = 'Running mean state, singular vectors and values of decomposed covariance matrix for FESOM2.1'
  END IF

  s = s + 1 ! 2
  stat(s) = NF_PUT_ATT_TEXT(ncid_out, NF_GLOBAL, 'title', LEN_TRIM(attstr), &
       TRIM(attstr))

  attstr = 'SSH, U, V, T, S, DIC, Alk, DIN, O2'
  s = s + 1 ! 3
  stat(s) = NF_PUT_ATT_TEXT(ncid_out, NF_GLOBAL, 'state_fields', LEN_TRIM(attstr), &
       TRIM(attstr))
  
  s = s + 1 ! 4
  stat(s) = NF_DEF_DIM(ncid_out, 'rank',  rank, dimid_rank)
  s = s + 1 ! 5
  stat(s) = NF_DEF_DIM(ncid_out, 'nod2',  dim_fields(idx% SSH), dimid_2D)            ! dim for 2D fields
  s = s + 1 ! 6
  stat(s) = NF_DEF_DIM(ncid_out, 'nz_x_nod2', dim_fields(idx% temp), dimid_tracer3D) ! dim for 3D fields
  s = s + 1 ! 7
  stat(s) = NF_DEF_DIM(ncid_out, 'dim_state', dim_state, dimid_state)
  s = s + 1 ! 8
  stat(s) = NF_DEF_DIM(ncid_out, 'one',  1, dimid_one)
  s = s + 1 ! 9
  stat(s) = NF_DEF_DIM(ncid_out, 'nfields',  nfields, dimid_nfields)

  ! Define variables
  ! singular values
  s = s + 1 ! 10
  stat(s) = NF_DEF_VAR(ncid_out, 'sigma', NF_DOUBLE, 1, dimid_rank, Id_sigma)
  
  ! mean states
  dimids(2) = dimid_one
  do b=fmin, fmax
  
    if (fproperties(b)% ndims==1) dimids(1) = dimid_2D
    if (fproperties(b)% ndims==2) dimids(1) = dimid_tracer3D
    
    stat(s) = NF_DEF_VAR(ncid_out, TRIM(fproperties(b)% variable)//'_mean', NF_REAL, 2, dimids, fproperties(b)% mid)
    s = s + 1
  enddo

  ! singular vectors
  dimids(2) = dimid_rank
  do b=fmin, fmax
  
    if (fproperties(b)% ndims==1) dimids(1) = dimid_2D
    if (fproperties(b)% ndims==2) dimids(1) = dimid_tracer3D
    
    stat(s) = NF_DEF_VAR(ncid_out, TRIM(fproperties(b)% variable)//'_svd', NF_REAL, 2, dimids, fproperties(b)% sid)
    s = s + 1
  enddo

  ! End define-mode
  stat(s) = NF_ENDDEF(ncid_out)

  DO i = 1,  s
     IF (stat(i) /= NF_NOERR) THEN
          WRITE(*, *) 'NetCDF error in init of output file, no.', i
          WRITE(*, *)  NF_STRERROR(stat(i))
     ENDIF
  END DO

  ! Write singular values
  s = 1
  stat(s) = NF_PUT_VAR_DOUBLE(ncid_out, id_sigma, svals(1:rank))
  
  ! Write running mean (for the last snap shot)
  startv2(2) = 1
  countv2(2) = 1
  startv2(1) = 1
          
  ! Write part of state vector for each field into one netCDF variable
  do b = fmin, fmax
       countv2(1) = dim_fields(b)
       s = s + 1
       stat(s) = NF_PUT_VARA_REAL(ncid_out, fproperties(b)% mid, startv2, countv2, &
            REAL(run_meanstate(1+offsets(b) : offsets(b)+dim_fields(b), maxtimes), 4))
  enddo

  DO i = 1,  s
     IF (stat(i) /= NF_NOERR) &
          WRITE(*, *) 'NetCDF error in writing running mean state, no.', i
  END DO


  ! *** Write singular vectors

  writevectors: DO i = 1, rank
  
     s=1

     write(*,*) 'writing rank ', i, ' to netCDF'
     startv2(2) = i ! rank
     countv2(2) = 1
     startv2(1) = 1
          
     ! Write part of state vector for each field
     do b = fmin, fmax
       countv2(1) = dim_fields(b)
       s = s + 1
       stat(s) = NF_PUT_VARA_REAL(ncid_out, fproperties(b)% sid, startv2, countv2, &
            REAL(svdU(1+offsets(b) : offsets(b)+dim_fields(b), i),4))
     enddo

     DO k = 1,  s
        IF (stat(k) /= NF_NOERR) THEN
             WRITE(*, *) 'NetCDF error in writing singular vectors, no.', k,' rank',i
             PRINT *, NF_STRERROR(stat(k))
        ENDIF
     END DO

  END DO writevectors

  ! Close file
  s = 1
  stat(s) = NF_CLOSE(ncid_out)

  DO i = 1,  s
     IF (stat(i) /= NF_NOERR) &
          WRITE(*, *) 'NetCDF error in singular vectors to output file, no.', i
  END DO


! ********************
! *** Finishing up ***
! ********************

  DEALLOCATE(states, meanstate)
  DEALLOCATE(svals, svdU)

  WRITE (*,'(/1x,a/)') '------- END -------------'

END PROGRAM generate_covar



















